{"version":3,"sources":["speclj/stub.cljc"],"mappings":";AAEA,AAAA,AAEA,8BAAA,9BAAOA;AAAP,AACE,oBACmBC;AADnB;;AAAA,AAEE,MAAO,WAAA,NAAuCC;;;AAGlD;;;0BAAA,1BAAMC;AAAN,AAGE,AAACH;;AACD,yEAAA,lEAACI,sBAAOH;;AAEV,iCAAA,jCAAMI,0EAAoBC,KAAKC;AAA/B,AACE,AAACP;;AACD,IAAMO,WAAK,2DAAA,zDAAI,6CAAA,7CAACC,kDAAMD,wCAAS,AAACE,cAAIF;AAApC,AACE,qHAAA,9GAACG,mDAAMT,4CAAsBU,kGAAML,KAAKC;;AAUzC,8BAAA,9BAAOK,oEAAiBN,KAAKO,SAASN;AAAtC,AACE,AAAA,AACE,OAACO,8CAAMD,SAASN;;AAEvB,AAAA,mBAAA,2BAAAQ,9CAAME;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,+CAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,+CAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAf,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,iDAAA,jDAAMe,4DACFX;AADJ,AACU,2DAAA,pDAACY,+CAAKZ;;;AADhB,CAAA,iDAAA,jDAAMW,4DAEFX,KAAKa;AAFT,AAGG,IAAMN,WAAS,AAAA,uFAASM;AAAxB,AACE,oBAAM,iBAAAC,oBAAKP;AAAL,AAAA,oBAAAO;AAAc,UAAK,AAACC,qBAAKR;;AAAzBO;;;AAAN,AACE,MAAO,WAAA,NAAuClB;;AADhD;;AAEA;mCAAOK;AAAP,AACE,AAACF,+BAAmBC,KAAKC;;AACzB,IAAMe,SAAO,4EAAA,1DAAIT,UAAS,AAACD,4BAAgBN,KAAKO,SAASN;AAAzD,AACE,IAAAgB,2BAAqB,AAAA,sFAAQJ;AAA7B,AAAA,oBAAAI;AAAA,AAAA,sBAAAA,lBAAWC;AAAX,AACE,MAAOA;;AADT;;AAEA,GAAI,kCAAA,lCAACC,0BAAUN;AACb,OAAA,wFAASA;;AACTG;;;;IAPCf;;;;EAAAA;;oCAAAA;;;IAAAA;0BAAAA;;;;;;;;AANZ,CAAA,2CAAA,3CAAMU;;AAAN,AAeA;;;6BAAA,7BAAMS,kEAEHpB;AAFH,AAGE,OAACqB,4CAAIC,iBACA,+CAAA,WAAAC,1DAACE;AAAD,AAAS,OAACvB,6CAAEF,KAAK,gBAAAuB,hBAACG;GAAlB,AAAAF,gBACS7B;;AAEhB;;;kCAAA,lCAAMgC,4EAEH3B;AAFH,AAGE,OAAC0B,gBAAM,AAACN,2BAAepB;;AAEzB;;;iCAAA,jCAAM4B,0EAEH5B;AAFH,AAGE,OAAC6B,eAAK,AAACT,2BAAepB;;AAExB,kCAAA,lCAAM8B,4EAAeC,SAASC;AAA9B,AACE,oDAAA,2CAAA,tFACE,AAACC,4BAAYF,iBACb,AAACE,4BAAYD,eACb,AAAC9B,6CAAE,AAACgC,gBAAMH,UAAU,AAACG,gBAAMF,cAC3B,AAACG,uBAAOC,sBACA,AAACf,4CACC,WAAKgB,EAAEC;AAAP,AACE,GACE,6CAAA,7CAACpC,6FAAKmC;AADR;;AAAA,GAEE,AAACE,oBAAIF;AAAG,IAAAG,mBAAI,AAACtC,6CAAEmC,EAAEC;AAAT,AAAA,GAAAE;AAAAA;;AAAY,QAACH,kCAAAA,qCAAAA,LAAEC,kBAAAA;;;AAFzB,AAGQ,OAACpC,6CAAEmC,EAAEC;;;;GACfP,SAASC","names":["speclj.stub/check-recording","speclj.stub/*stubbed-invocations*","js/Error","speclj.stub/clear!","cljs.core/reset!","speclj.stub/-record-invocation","name","args","cljs.core._EQ_","cljs.core/vec","cljs.core.swap_BANG_","cljs.core/conj","speclj.stub/invoke-delegate","delegate","cljs.core.apply","var_args","G__44402","speclj.stub/stub","speclj.stub.stub","options","and__5000__auto__","cljs.core/ifn?","result","temp__5823__auto__","throwable","cljs.core/contains?","speclj.stub/invocations-of","cljs.core.map","cljs.core/second","p1__44407#","cljs.core/deref","cljs.core.filter","cljs.core/first","speclj.stub/first-invocation-of","speclj.stub/last-invocation-of","cljs.core/last","speclj.stub/params-match?","expected","actual","cljs.core/sequential?","cljs.core/count","cljs.core/every?","cljs.core/true?","e","a","cljs.core/fn?","or__5002__auto__"],"sourcesContent":["(ns speclj.stub)\n\n(declare ^:dynamic *stubbed-invocations*)\n\n(defn- check-recording []\n  (when-not #?(:clj  (bound? #'*stubbed-invocations*)\n               :cljs *stubbed-invocations*)\n    (throw (new #?(:clj java.lang.Exception :cljs js/Error)\n                \"Stub recoding not bound.  Please add (with-stubs) to the decribe/context.\"))))\n\n(defn clear!\n  \"Removes all previous stub invocations to continue with a blank slate.\"\n  []\n  (check-recording)\n  (reset! *stubbed-invocations* []))\n\n(defn -record-invocation [name args]\n  (check-recording)\n  (let [args (if (= nil args) [] (vec args))]\n    (swap! *stubbed-invocations* conj [name args])))\n\n#?(:clj\n   (defn- invoke-delegate [name delegate args]\n     (try\n       (apply delegate args)\n       (catch clojure.lang.ArityException e\n         (throw (java.lang.Exception. (str \"Stub \" name \" was invoked with \" (.-actual e) \" arguments, but the :invoke fn has a different arity\"))))))\n\n   :cljs\n   (defn- invoke-delegate [name delegate args]\n     (try\n       (apply delegate args))))\n\n(defn stub\n  ([name] (stub name {}))\n  ([name options]\n   (let [delegate (:invoke options)]\n     (when (and delegate (not (ifn? delegate)))\n       (throw (new #?(:clj java.lang.Exception :cljs js/Error) \"stub's :invoke argument must be an ifn\")))\n     (fn [& args]\n       (-record-invocation name args)\n       (let [result (if delegate (invoke-delegate name delegate args) nil)]\n         (when-let [throwable (:throw options)]\n           (throw throwable))\n         (if (contains? options :return)\n           (:return options)\n           result))))))\n\n(defn invocations-of\n  \"Returns a list of argument lists representing each invocation of the specified stub.\"\n  [name]\n  (map second\n       (filter #(= name (first %))\n               @*stubbed-invocations*)))\n\n(defn first-invocation-of\n  \"Returns the list of arguments passed into the first invocation of the specified stub, nil if it was never invoked.\"\n  [name]\n  (first (invocations-of name)))\n\n(defn last-invocation-of\n  \"Returns the list of arguments passed into the last invocation of the specified stub, nil if it was never invoked.\"\n  [name]\n  (last (invocations-of name)))\n\n(defn params-match? [expected actual]\n  (and\n    (sequential? expected)\n    (sequential? actual)\n    (= (count expected) (count actual))\n    (every? true?\n            (map\n              (fn [e a]\n                (cond\n                  (= :* e) true\n                  (fn? e) (or (= e a) (e a))\n                  :else (= e a)))\n              expected actual))))\n\n"],"x_google_ignoreList":[0]}